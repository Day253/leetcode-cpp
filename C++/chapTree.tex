\chapter{树}


\section{Binary Tree Level Order Traversal} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:binary-tree-tevel-order-traversal}


\subsubsection{描述}
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree \code{\{3,9,20,\#,\#,15,7\}},
\begin{Code}
    3
   / \
  9  20
    /  \
   15   7
\end{Code}
return its level order traversal as:
\begin{Code}
[
  [3],
  [9,20],
  [15,7]
]
\end{Code}


\subsubsection{分析}
无


\subsubsection{代码}
\begin{Code}
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

//LeetCode, Binary Tree Level Order Traversal
class Solution {
public:
    vector<vector<int> > levelOrder(TreeNode *root) {
        vector<vector<int> > result;
        if(root == NULL) return result;

        queue<TreeNode*> queToPush, queToPop;
        queToPop.push(root);
        while (!queToPop.empty()) {
            vector<int> level; // elments in level level

            while (!queToPop.empty()) {
                TreeNode* node = queToPop.front();
                queToPop.pop();
                level.push_back(node->val);
                if (node->left != NULL) queToPush.push(node->left);
                if (node->right != NULL) queToPush.push(node->right);
            }
            result.push_back(level);
            swap(queToPush, queToPop); //!!! how to use swap
        }
        return result;
    }
};
\end{Code}


\subsubsection{相关题目}
\begindot
\item Binary Tree Level Order Traversal II，见 \S \ref{sec:binary-tree-tevel-order-traversal-ii}
\item Binary Tree Zigzag Level Order Traversal，见 \S \ref{sec:binary-tree-zigzag-level-order-traversal}
\myenddot


\section{Binary Tree Level Order Traversal II} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:binary-tree-tevel-order-traversal-ii}


\subsubsection{描述}
Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

For example:
Given binary tree \code{\{3,9,20,\#,\#,15,7\}},
\begin{Code}
    3
   / \
  9  20
    /  \
   15   7
\end{Code}
return its bottom-up level order traversal as:
\begin{Code}
[
  [15,7]
  [9,20],
  [3],
]
\end{Code}


\subsubsection{分析}
在Binary Tree Level Order Traversal I（见\S \ref{sec:binary-tree-tevel-order-traversal}）的基础上，用一个list作为栈，每次在头部插入，就可以实现倒着输出


\subsubsection{代码}
\begin{Code}
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) { }
};

//LeetCode, Binary Tree Level Order Traversal II
//在Binary Tree Level Order Traversal I的基础上，用一个list作为栈
//每次在头部插入，就可以实现倒着输出
class Solution {
public:
    vector<vector<int> > levelOrderBottom(TreeNode *root) {
        list<vector<int> > retTemp;

        queue<TreeNode *> q;
        q.push(root);
        q.push(NULL); // level separator

        vector<int> level;  // elements in one level
        while(!q.empty()) {
            TreeNode *cur = q.front();
            q.pop();
            if(cur) {
                level.push_back(cur->val);
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            } else {
                if(level.size() > 0) {
                    retTemp.push_front(level);
                    level.erase(level.begin(),level.end());
                    q.push(NULL);
                }
            }
        }

        vector<vector<int> > ret;
        for(list<vector<int> >::iterator it = retTemp.begin();
                it != retTemp.end(); ++it) {
            ret.push_back(*it);
        }
        return ret;
    }
};
\end{Code}


\subsubsection{相关题目}
\begindot
\item Binary Tree Level Order Traversal，见 \S \ref{sec:binary-tree-tevel-order-traversal}
\item Binary Tree Zigzag Level Order Traversal，见 \S \ref{sec:binary-tree-zigzag-level-order-traversal}
\myenddot


\section{Binary Tree Zigzag Level Order Traversal} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:binary-tree-zigzag-level-order-traversal}


\subsubsection{描述}
Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree \code{{3,9,20,\#,\#,15,7}},
\begin{Code}
    3
   / \
  9  20
    /  \
   15   7
\end{Code}
return its zigzag level order traversal as:
\begin{Code}
[
  [3],
  [20,9],
  [15,7]
]
\end{Code}


\subsubsection{分析}
广度优先遍历，用一个bool记录是从左到右还是从右到左，每一层结束就翻转一下。


\subsubsection{代码}
\begin{Code}
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};

//LeetCode, Binary Tree Zigzag Level Order Traversal
//广度优先遍历，用一个bool记录是从左到右还是从右到左，每一层结束就翻转一下。
class Solution {
public:
    vector<vector<int> > zigzagLevelOrder(TreeNode *root) {
        vector<vector<int> > result;
        if (NULL == root) return result;

        queue<TreeNode*> q;
        bool l2r = true;  //left to right
        vector<int> level;  // one level's elements

        q.push(root);
        q.push(NULL);  // level separator
        while (!q.empty()) {
            TreeNode *cur = q.front();
            q.pop();
            if (cur) {
                level.push_back(cur->val);
                if (cur->left) q.push(cur->left);
                if (cur->right) q.push(cur->right);
            } else {
                if (l2r) {
                    result.push_back(level);
                } else {
                    vector<int> temp;
                    for (int i = level.size() - 1; i >= 0; --i) {
                        temp.push_back(level[i]);
                    }
                    result.push_back(temp);
                }
                level.clear();
                l2r = !l2r;

                if (q.size() > 0) q.push(NULL);
            }
        }

        return result;
    }
};
\end{Code}


\subsubsection{相关题目}
\begindot
\item Binary Tree Level Order Traversal，见 \S \ref{sec:binary-tree-tevel-order-traversal}
\item Binary Tree Level Order Traversal II，见 \S \ref{sec:binary-tree-tevel-order-traversal-ii}
\myenddot