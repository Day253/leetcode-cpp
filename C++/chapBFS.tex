\chapter{广度优先搜索}
当题目看不出任何规律，既不能用分治，贪心，也不能用动规时，这时候万能方法——搜索，
就派上用场了。搜索分为广搜和深搜，广搜里面又有普通广搜，双向广搜，A*搜索等。
深搜里面又有普通深搜，回溯法等。

广搜和深搜非常类似（除了在扩展节点这部分不一样），二者有相同的框架，如何表示状态？
如何扩展状态？如何判重？尤其是判重，解决了这个问题，基本上整个问题就解决了。


\section{Word Ladder} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:wordladder}


\subsubsection{描述}
Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that:
\begindot
\item Only one letter can be changed at a time
\item Each intermediate word must exist in the dictionary
\myenddot

For example, Given:

\begin{Code}
start = "hit"
end = "cog"
dict = ["hot","dot","dog","lot","log"]
\end{Code}
As one shortest transformation is \code{"hit" -> "hot" -> "dot" -> "dog" -> "cog"}, return its length $5$.

Note:
\begindot
\item Return 0 if there is no such transformation sequence.
\item All words have the same length.
\item All words contain only lowercase alphabetic characters.
\myenddot


\subsubsection{分析}


\subsubsection{代码}
\begin{Code}
//LeetCode, Word Ladder
class Solution {
public:
    typedef string state_t;
    int ladderLength(string start, string end,
            const unordered_set<string> &dict) {
        if (start.size() != end.size()) return 0;
        if (start.empty() || end.empty()) return 0;

        queue<string> next, current; // 当前层，下一层
        unordered_set<string> visited; // 判重
        unordered_map<string, string > father;
        int level = 0;  // 层次
        bool found = false;

        current.push(start);
        while (!current.empty() && !found) {
            ++level;
            while (!current.empty() && !found) {
                const string str(current.front()); current.pop();

                for (size_t i = 0; i < str.size(); ++i) {
                    string new_word(str);
                    for (char c = 'a'; c <= 'z'; c++) {
                        if (c == new_word[i]) continue;

                        swap(c, new_word[i]);
                        if (new_word == end) {
                            found = true; //找到了
                            father[new_word] = str;
                            break;
                        }

                        if (dict.count(new_word) > 0
                                && !visited.count(new_word)) {
                            next.push(new_word);
                            visited.insert(new_word);
                            father[new_word] = str;
                        }
                        swap(c, new_word[i]); // 恢复该单词
                    }
                }
            }
            swap(next, current); //!!! 交换两个队列
        }
        if (found) return level+1;
        else return 0;
    }
};
\end{Code}


\subsubsection{相关题目}

\begindot
\item Word Ladder II，见 \S \ref{sec:wordladderii}
\myenddot


\section{Word Ladder II} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:wordladderii}


\subsubsection{描述}
Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:
\begindot
\item Only one letter can be changed at a time
\item Each intermediate word must exist in the dictionary
\myenddot

For example, Given:
\begin{Code}
start = "hit"
end = "cog"
dict = ["hot","dot","dog","lot","log"]
\end{Code}
Return
\begin{Code}
[
    ["hit","hot","dot","dog","cog"],
    ["hit","hot","lot","log","cog"]
]
\end{Code}

Note:
\begindot
\item All words have the same length.
\item All words contain only lowercase alphabetic characters.
\myenddot


\subsubsection{分析}
跟 Word Ladder比，这题是求路径本身，不是路径长度，也是BFS，略微麻烦点。

这题跟普通的广搜有很大的不同，就是要输出所有路径，因此在记录前驱和判重地方与普通广搜略有不同。


\subsubsection{代码}

\begin{Code}
//LeetCode, Word Ladder II
class Solution {
public:
    vector<vector<string> > findLadders(string start, string end,
            const unordered_set<string> &dict) {
        unordered_set<string> visited; // 判重
        unordered_map<string, vector<string> > father; // 树
        unordered_set<string> current, next;  // 当前层，下一层，用集合是为了去重

        int level = 0; // 层数
        bool found = false;

        current.insert(start);
        while (!current.empty() && !found) {
            ++level;
            // 先将本层全部置为已访问，防止同层之间互相指向
            for (auto iter = current.begin(); iter != current.end(); ++iter)
                visited.insert(*iter);
            for (auto iter = current.begin(); iter != current.end(); ++iter) {
            //while (!current.empty()) {
                const string word = *iter;

                for (size_t i = 0; i < word.size(); ++i) {
                    string new_word = word;
                    for (char c = 'a'; c <= 'z'; ++c) {
                        if (c == new_word[i]) continue;
                        swap(c, new_word[i]);

                        if (new_word == end) found = true; //找到了

                        if (visited.count(new_word) == 0
                                && (dict.count(new_word) > 0 ||
                                        new_word == end)) {
                            next.insert(new_word);
                            father[new_word].push_back(word);
                            // visited.insert(new_word)移动到最上面了
                        }

                        swap(c, new_word[i]);  // restore
                    }
                }
            }

            current.clear();
            swap(current, next);
        }
        vector<vector<string> > result;
        if (found) {
            vector<string> path;
            buildPath(father, path, start, end, result);
        }
        return result;
    }
private:
    void buildPath(unordered_map<string, vector<string> > &father,
            vector<string> &path, const string &start, const string &word,
            vector<vector<string> > &result) {
        path.push_back(word);
        if (word == start) {
            result.push_back(path);
            reverse(result.back().begin(), result.back().end());
        } else {
            for (auto iter = father[word].begin(); iter != father[word].end();
                    ++iter) {
                buildPath(father, path, start, *iter, result);
            }
        }
        path.pop_back();
    }
};
\end{Code}


\subsubsection{相关题目}

\begindot
\item Word Ladder，见 \S \ref{sec:wordladder}
\myenddot
